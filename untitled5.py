# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tU0MuWtF_bCWkpqs2JjW7w1nWKWHDKNh
"""

from scipy.optimize import curve_fit
from numpy import arange
from matplotlib import pyplot
import pandas as pd
import numpy as np
import sklearn.cluster as cluster
import sklearn.metrics as skmet
import matplotlib.pyplot as plt

#entire file path
filePath="/content/API_19_DS2_en_csv_v2_4773766.csv"
text_file = open(filePath,'r')
line_list = text_file.readlines()

with open("output.csv", "w") as txt_file:
    for line in line_list[4:]:
        txt_file.write(line)

#SP.POP.TOTL
#EG.USE.ELEC.KH.PC
df = pd.read_csv("output.csv",engine="python")
df=df.fillna(0)
#df=df.drop(["Unnamed: 66"],axis=1)
options=["SP.POP.TOTL","EG.USE.ELEC.KH.PC"]
result_df=df[df['Indicator Code'].isin(options)]
columns=result_df.columns
temp_df=result_df.drop(columns[:4],axis=1).transpose()
result_df["output"]=temp_df.mean()

result_df=result_df[["Country Name","Indicator Code","output"]]
population=result_df[df["Indicator Code"]=="SP.POP.TOTL"]
electricityCosumption=result_df[df["Indicator Code"]=="EG.USE.ELEC.KH.PC"]
countryCode=list(set(list(result_df["Country Name"])))
data=np.empty((0, 3))
for i in countryCode:
  if(electricityCosumption[electricityCosumption['Country Name']==i]["output"].empty):
    continue
  electricityCosumptionForCountry=float(electricityCosumption[electricityCosumption['Country Name']==i]["output"])
  populationForCountry=float(population[population['Country Name']==i]["output"])
  data=np.append(data,np.array([[i,electricityCosumptionForCountry,populationForCountry]]),axis=0)
data

ncluster = 4
xy=data[:,1:]
x=data[:,1]
y=data[:,2]
# set up the clusterer with the number of expected clusters
kmeans = cluster.KMeans(n_clusters=ncluster)
# Fit the data, results are stored in the kmeans object
kmeans.fit(xy) # fit done on x,y pairs
labels = kmeans.labels_
#print(labels) # labels is the number of the associated clusters of (x,y)‚ê£

# for i in range(50):
# print(xy[i], labels[i])
# extract the estimated cluster centres
cen = kmeans.cluster_centers_
print(cen)
# calculate the silhoutte score
print(skmet.silhouette_score(xy, labels))
# plot using the labels to select colour
plt.figure(figsize=(10.0, 10.0))
col = ["tab:blue", "tab:orange", "tab:green", "tab:red", "tab:purple", "tab:brown", "tab:pink", "tab:gray", "tab:olive", "tab:cyan"]
for l in range(0,ncluster): # loop over the different labels
  plt.plot(x[labels==l], y[labels==l], "o", markersize=4, color=col[l])
plt.xlabel("x")
plt.ylabel("y")
plt.show()
# show cluster centres
'''for ic in range(ncluster):
  xc, yc = cen[ic,:]
plt.plot(xc, yc, "dk", markersize=10)
plt.xlabel("x")
plt.ylabel("y")
plt.show()'''

country=data[:,0]
for i in range(ncluster):
  print("Cluster="+str(i))
  print(country[labels==i])

result_df=df[df['Indicator Code'].isin(options)]
result_df=result_df[result_df["Country Name"]=="India"]
result_df=result_df.transpose()
temp_df=result_df.drop(columns[:4],axis=0)
temp_df=temp_df.drop(columns[-10:],axis=0)
temp_df.columns=["x","y"]
y=list(temp_df["y"])
x=[ int(x) for x in temp_df.index]
#result_df

def objective(x, a, b):
  return a*x+b

popt,covar= curve_fit(objective, x, y,absolute_sigma=True)
# summarize the parameter values
print(popt)
a, b = popt
sigma = np.sqrt(np.diag(covar))
print('y = %.5f * x+%.5f' % (a, b))
x_line = arange(min(x), 2030, 1)
y_line=list()
for i in x_line:
  y_line.append(objective(i, a, b))
#y_line = objective(x_line, a, b)
labels=list()
pyplot.plot(x, y,label="data")
pyplot.plot(x_line, y_line,label="chi-square fitting")
plt.xlabel(r'year', fontsize=20)
plt.ylabel(r'electricity consumtion per capita', fontsize=20)
plt.legend(bbox_to_anchor =(1.75, 1.15), ncol = 5)
f = plt.figure()
f.set_figwidth(1000)
f.set_figheight(1000)
plt.show()

def err_ranges(x, func, param, sigma):
    import itertools as iter
    
    # initiate arrays for lower and upper limits
    lower = [func(i, *param) for i in x]
    upper = lower
    
    uplow = []   # list to hold upper and lower limits for parameters
    for p,s in zip(param, sigma):
        pmin = p - s
        pmax = p + s
        uplow.append((pmin, pmax))
        
    pmix = list(iter.product(*uplow))
    
    for p in pmix:
        y = [func(i, *p) for i in x]
        lower = np.minimum(lower, y)
        upper = np.maximum(upper, y)
    print(lower)
    print(upper)  
    return lower, upper 
lower,upper=err_ranges(x,objective,[a,b],sigma)

forecast = [objective(i,a,b) for i in x]
plt.figure()
plt.plot(x, y, label="year vs electricity cosumption per capita")
plt.plot(x, forecast, label="forecast")
plt.fill_between(x, lower, upper, color="yellow", alpha=0.7)
plt.xlabel("year")
plt.ylabel("GDP")
plt.legend()
plt.show()